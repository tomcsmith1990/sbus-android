\documentclass[12pt,twoside,notitlepage]{report}

\usepackage{a4}
\usepackage{verbatim}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}

% set tab size for lstlisting
\lstset{tabsize=4}

\input{epsf}                            % to allow postscript inclusions
% On thor and CUS read top of file:
%     /opt/TeX/lib/texmf/tex/dvips/epsf.sty
% On CL machines read:
%     /usr/lib/tex/macros/dvips/epsf.tex



\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{6mm}       % adjust margins
\addtolength{\evensidemargin}{-8mm}

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\hfill{\LARGE \bf Thomas Smith}

\vspace*{60mm}
\begin{center}
\Huge
{\bf Automatic Configuration in Mobile Environments} \\
\vspace*{5mm}
Computer Science Tripos Part II \\
\vspace*{5mm}
Sidney Sussex College \\
\vspace*{5mm}
\today  % today's date
\end{center}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
Name:               & \bf Thomas Smith	\\
College:            & \bf Sidney Sussex College	\\
Project Title:      & \bf Automatic Configuration \\ &\bf in Mobile Environments	\\
Examination:        & \bf Computer Science Tripos Part II, 2013 	\\
Word Count:         & \bf 2466\footnotemark[1] \\
Project Originator: & Dr Jatinder Singh		\\
Supervisor:         & Dr Jatinder Singh		\\ 
\end{tabular}
}

\footnotetext[1]{This word count was computed by {\tt detex diss.tex | tr -cd '0-9A-Za-z $\tt\backslash$n' | wc -w}}
\stepcounter{footnote}


\section*{Original Aims of the Project}

The original aim of the project was to create a system which could adapt to the changes in context which come with mobility, such as location or networks. 
This required the ability to detect these changes, in order to find and connect to new data sources. 
As a new data source may have different data schema to the expected schema, the system must offer a way to make meaningful use of this data in relation to the expected schema.

\section*{Work Completed}

A messaging middleware was modified to allow users to search for data sources by aspects of their schema. Users can search for an exact match on some part of a schema, or a looser match which only considers field types, and not names.
Once this middleware was ported for use on Android, an application was created to monitor changes in context, particularly those that arise as a result of mobility. Upon detection of a change in context, the application informs other applications of the change, or automatically reconfigures their connections to connect them to a new data source.

\section*{Special Difficulties}

The main difficulty in the project came from porting the messaging middleware to Android. The Android NDK\footnote{http://developer.android.com/tools/sdk/ndk/index.html} toolkit was used in order to compile C++ for use on Android, however missing libraries and poor documentation made this task more difficult than expected.
 
\newpage
\section*{Declaration}

I Thomas Smith of Sidney Sussex College, being a candidate for Part II of the Computer
Science Tripos, hereby declare that this dissertation and the work described in it are my own work,
unaided except as may be specified below, and that the dissertation
does not contain material that has already been used to any substantial
extent for a comparable purpose.

\bigskip
\leftline{Signed: }

\bigskip
\leftline{Date: }

\cleardoublepage

\tableofcontents

\listoffigures

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\cleardoublepage        % just to make sure before the page numbering
                        % is changed

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

% Intro + Preparation ~ 1400 words
\chapter{Introduction}

% summarise
While many applications now exist for mobile devices, few applications themselves are truly mobile. 
The user may happen to be mobile, however the application does not adapt to different environments. 
This project addresses the issues faced in creating applications which can change to suit different environments. 
I show how relevant data sources in an environment can be found for applications, and how flexibility in the data they use can be achieved. 

\section{Problem}
% what's the problem
% describe current approach
Different environments mean that devices operate in different contexts and scopes, which dictate how a device can interact with the environment. 
% describe context more, then say you're mainly focusing on mobility
Context may consist of both physical attributes, such as available Wi-Fi networks and location, as well as psychological aspects such as the user's behaviour or mood.
For example, the device may deduce from the accelerometer that the user is running, in which case the user may be in a rush and require different data than if they were sat calmly.
Scope is also an important factor, since data sources may only be available on a particular network, or within a given time period. 
Changes in context and scope mean that an application may no longer be able to communicate with a given data source, or the data it is providing may no longer be useful. 
In this situation, an alternative data source must be found.

Once this alternate data source has been found, the application must still determine whether it provides useful data. 
Some data may be absolutely necessary for operation of the application, while other parts may be desired, but operation can continue without them. 
However, even if a data source is deemed useful, the application may still have the difficulty of the data being presented in an alternate format to the expected format. 
Some fields may be missing, there may be additional fields, and some fields may have different names. 
The application may also wish to specify some subscription filter about the messages it should receive, yet without knowledge of the data format, it cannot specify constraints on different fields.

% example
For example, a transport application may face differences in data available for coaches (Figure \ref{fig:coach-schema}) and for trains (Figure \ref{fig:train-schema}). 
While both offer similar data to a large extent, fields are named differently, and the train schema also offers a menu for an on-board shop.
Furthermore, if the application were to be used abroad, for example in a French coach station, the data will still be very similar, but fields names may be in French (Figure \ref{fig:french-coach-schema}).

While these differences may be important when the user is sat waiting in a station, they become less important if the user is running to catch a coach or a train and simply requires the departure time and location.
Given the amount of uncertainty about what data will be available, a developer creating this application cannot hope to account for all possibilities. 
However, the developer can specify how the application should behave in different contexts.

\section{Project}

% what I've done
Schilit et al \cite{Schilit:1994:CCA:1439278.1440041}  define a context-aware system as one which can examine the computing environment and react to changes in the environment. 
This project creates such a system, which performs automatic contextual reconfiguration for applications whenever there is a change in the environment. 
Pascoe \cite{Pascoe:1998:AGC:857199.858020} lists four context-aware capabilites, two of which occur in this reconfiguration. 
Contextual resource discovery is used to discover data sources available within the context, and contextual adaptation allows applications to adapt to these data sources' schemas in order to use the sources.

A ``mobile policy engine'' is the part of the system which performs the automatic reconfiguration. 
Applications control how their connections should be reconfigured through policies. 
These policies may specify the name of a data sources, or be more complex rules regarding the structure of data sources' schemas. 
The policy engine monitors the environment, and upon detecting a change applies these policies, connecting applications to different data sources where appropriate.
Alternatively, applications may opt to be notified of a relevant change, rather than have their connection reconfigured, allowing them to perform callback methods upon a change.

Depending on the policy, an application may be connected to a data source which does not offer the expected data schema. 
The system handles this by repackaging messages to match the application's schema. Any extraneous fields are removed, while any absent fields are filled with ``empty'' values. The policy is used to infer relationships between fields, even if they have different names. 
Once the system has repackaged the message, it passes it to the application, allowing the application to continue as if it had received a message conforming to its schema.

The system allows an application to specify subscription filters in terms of its own schema. 
As part of the reconfiguration process the system converts this subscription to match the data source's schema, connecting the application with a working subscription in place.

\cleardoublepage

 
\chapter{Preparation}


\cleardoublepage


% ~ 4000 words
\chapter{Implementation}


\cleardoublepage


% ~ Eval + Conclusion ~ 2000 words
\chapter{Evaluation}

\begin{itemize}
\item
{\bf TEST: } How long does the RDC take to find a matching schema (at the end of the list of components) when there are 0, 10, 50, 100 other components? How much faster is it with optimisations to put structure constraints or exact constraints (or both) first?\\
{\bf REASON: } In reality, will have some other components, don't want too big a delay, especially if it affects other components. Could optimise searches with a hash table?

\item
{\bf TEST: } How long does it take for components to have connections reconfigured after connecting to a new Wi-Fi network?\\
{\bf REASON: } If a lot of components are registered on the phone, how long does it take to get to the last one? Perhaps some priority is needed?

\item
{\bf TEST: } How long does it take to repack messages for: similar size schemas (e.g. just different names), much larger schemas (removing fields), much smaller fields (adding fields)?\\
{\bf REASON: } Some applications may be time sensitive (e.g. stock market). Don't want to wait ages for each message to be repacked.

\item
{\bf TEST: } How long does it take to construct a lookup table for: similar size schemas, much larger schemas, much smaller fields?\\
{\bf REASON: } Again, time sensitive.

\item How accurate is the lookup table? Are any fields repackaged as ``empty'' when we could have filled them with something else? Fairly qualitative, perhaps a discussion about how the constraints are used to create this lookup table, and how multiple constraints may be fulfilled by a single field. Possibly more suited to Implementation or Conclusion?

\item Should multiple constraints (e.g. must have two int fields) be allowed to match to the same field?

\item Some screenshots? Perhaps just showing a repackaged message being passed to a consumer and the original sensor message?

\item Example code for Android consumer, showing how easy flexibility is?

\item Why the recursive discovery through peer inspection hasn't been implemented, and how it could be (should be somewhere else?)

\item Alternative search algorithms for schema comparison in RDC. What performance increases they may offer, and how the results would vary (i.e. a breadth first search would return the schema which matches the constraints at the highest level).

\item Table of example policies, how reconfiguration works.
\end{itemize}


\cleardoublepage

\chapter{Conclusion}

% summarise
The project has created a context-aware system which enables developers to write applications without prior knowledge of the location of data sources, or the format of their data. 

Upon detecting a change in context, the ``mobile policy engine'' applies applications' policies, reconfiguring their connections as appropriate. 
These policies may be simple, such as the name of a data source, or more complex, specifying how fields in a data source's schema must match the application's own, in terms of exact matches, type-matches, or uninterested. 
Through these policies, applications can place restrictions on which data sources they can be connected to, without requiring applications to find data sources themselves.

Applications will only ever be presented with data conforming to their own schema, removing uncertainty about the format of the data.
Furthermore, applications may specify subscription filters in terms of their own schemas, placing restrictions on which messages they will be sent, without requiring knowledge of peers' schemas.
When reconfiguring a connection, the system translates these filters to match peer's schema and applies them to the peer, filtering messages as dictated by the application.

% example
Referring back to the transport example from the Introduction, there may be an application using the coach schema (Figure \ref{fig:coach-schema}) which requires data sources to offer a structure matching the type of the {\tt coach} structure. 
At a coach station, all data sources will match this schema exactly, so the application can connect to any one of them. 
Upon arriving at a larger station and connecting to a Wi-Fi network, the system detects a change in context, and consequently connects the application to a new data source. 
The user may be changing to a train here, however information about trains use a different schema (Figure \ref{fig:train-schema}). 
This schema does not match the application schema exactly, however it does contain a structure matching the necessary {\tt coach} structure. 
Therefore, the system can connect the application to this data source and repackage messages to match the application schema, allowing the same application code to handle the message. 
The user could have subscribed to only receive data for which the departure time is after midday. 
Since this subscription is specified in terms of the coach schema, it will not function correctly if applied directly to the train schema. 
In this case, the system reformats the subscription to match the train schema and applies it when connecting the application to the data source, ensuring the user's subscription filter is met.

The application might equally have used the train schema, yet only required the {\tt info} structure, allowing it to use coach data sources.

\section{Issues}
% remaining problems
The system currently faces issues when context is rapidly changing, for example, moving in and out of range of a Wi-Fi network. 
The network connection drops causing the system to reconfigure connections, which may disconnect applications from their peers.
However, the network connection is almost immediately re-established causing the system to reconfigure connections again, possibly connecting applications to these same peers. 
If this reconnection occurs before disconnection has completed, the application believes itself to still be connected to the peer, thus will not create a new connection.

A solution to this problem might be to implement constraints which must be satisfied before reconfiguration occurs. 
In a Wi-Fi network, there may be a constraint that the network signal must be greater than a given threshold, meaning no reconfiguration would occur until the user moves firmly into the network. 
If a context change depended on the accelerometer, it might be that the accelerometer must detect some pattern for several seconds before reconfiguration.

\section{Changes}
% what I'd have done differently
{\sl I think this section might be more obvious after writing in the Preparation chapter about how the project was planned. }


\section{Future Work}
% other stuff that could be done

The system currently depends solely on a change in network status to detect a change in context. 
The Android platform offers a whole host of different events\footnote{http://developer.android.com/reference/android/content/Intent.html} and sensors\footnote{http://developer.android.com/guide/topics/sensors/sensors\_overview.html} which could be used to determine a change in context, such as the battery level being low, the timezone changing, or accelerometer readings. 
The system could be extended to use more of these features to determine a change in context, allowing applications to specify how they want to react to different types of change in context. 
In addition to applications specifying the types of change in context they are interested in, the user may have the ability to specify which types of context change are allowed to be used. 
This offers some privacy to the user by allowing them to block applications from knowing if some part of their context has changed.

The constraints an application specifies about the schema of data sources it may be connected to are currently specified using the field names of the application schema.
While this works provided there are no repeated fields names within a schema, it would fail on a schema such as Figure \ref{fig:repeatednameschema}. 
A solution to this would be to qualify all names specified in the constraints in a similar way to subscriptions. 
We could specify a constraint for {\tt sensor}, meaning the entire structure, or {\tt sensor/sensor}, meaning the text field.

\begin{figure}[h]
\begin{lstlisting}
@sensor
{
	txt sensor
	int value
}
\end{lstlisting}
\caption[Schema with repeated name]{A schema with a structure named {\tt sensor} and a text field also named {\tt sensor}. A constraint specified on {\tt sensor} would be ambiguous without fully qualified names.}
\label{fig:repeatednameschema}
\end{figure}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the bibliography

\addcontentsline{toc}{chapter}{Bibliography}
% nocite means add all references even if not cited - TODO: remove in final version
\nocite{*}
\bibliography{refs}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\appendix

\chapter{Possible Titles}

\begin{itemize}
\item Automatic Communication Configuration in Mobile Environments
\item Data Stream Connection and Message Negotiation
\item Flexibile Data Streams in Mobile Environments
\item Automatic Data Stream Configuration in Mobile Environments
\end{itemize}

\cleardoublepage

\chapter{Example Schemas}

\input{schemas}

\cleardoublepage

% should this be an appendix?
\chapter{Project Proposal}

\input{propbody}

\end{document}
