\documentclass[12pt,twoside,notitlepage]{report}

\usepackage{a4}
\usepackage{verbatim}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}

% set tab size for lstlisting
\lstset{tabsize=4}

\input{epsf}                            % to allow postscript inclusions
% On thor and CUS read top of file:
%     /opt/TeX/lib/texmf/tex/dvips/epsf.sty
% On CL machines read:
%     /usr/lib/tex/macros/dvips/epsf.tex



\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{6mm}       % adjust margins
\addtolength{\evensidemargin}{-8mm}

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\hfill{\LARGE \bf Thomas Smith}

\vspace*{60mm}
\begin{center}
\Huge
{\bf Automatic Configuration in Mobile Environments} \\
\vspace*{5mm}
Computer Science Tripos Part II \\
\vspace*{5mm}
Sidney Sussex College \\
\vspace*{5mm}
\today  % today's date
\end{center}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
Name:               & \bf Thomas Smith	\\
College:            & \bf Sidney Sussex College	\\
Project Title:      & \bf Automatic Configuration \\ &\bf in Mobile Environments	\\
Examination:        & \bf Computer Science Tripos Part II, 2013 	\\
Word Count:         & \bf 5709\footnotemark[1] \\
Project Originator: & Dr Jatinder Singh		\\
Supervisor:         & Dr Jatinder Singh		\\ 
\end{tabular}
}

\footnotetext[1]{This word count was computed by {\tt detex -e `appendix,figure' diss.tex | tr -cd `0-9A-Za-z $\tt\backslash$n' | wc -w}}
\stepcounter{footnote}


\section*{Original Aims of the Project}

The original aim of the project was to create a system which could adapt to the changes in context which come with mobility, such as location or networks. 
This required the ability to detect these changes, in order to find and connect to new data sources. 
As a new data source may have different data schema to the expected schema, the system must offer a way to make meaningful use of this data in relation to the expected schema.

\section*{Work Completed}

A messaging middleware was modified to allow users to search for data sources by aspects of their schema. Users can search for exact matches on some part of a schema, or a looser matches, considering field types only, not names.
Once this middleware was ported for use on Android, an application was created to monitor changes in context, particularly those that arise as a result of mobility. Upon detection of a change in context, the application informs other applications of the change, or automatically reconfigures their connections to connect them to a new data source, based on their policies.

\section*{Special Difficulties}

The main difficulty in the project came from porting the messaging middleware to Android. The Android NDK\footnote{http://developer.android.com/tools/sdk/ndk/index.html} toolkit was used in order to compile C++ for use on Android, however missing libraries and poor documentation made this task more difficult than expected.
 
\newpage
\section*{Declaration}

I Thomas Smith of Sidney Sussex College, being a candidate for Part II of the Computer
Science Tripos, hereby declare that this dissertation and the work described in it are my own work,
unaided except as may be specified below, and that the dissertation
does not contain material that has already been used to any substantial
extent for a comparable purpose.

\bigskip
\bigskip
\leftline{Signed: }

\bigskip
\bigskip
\leftline{Date: }

\cleardoublepage

\tableofcontents

\listoffigures

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\cleardoublepage        % just to make sure before the page numbering is changed

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

% Intro + Preparation ~ 1400 words
\chapter{Introduction}

% summarise
While many applications now exist for mobile devices, few applications themselves are truly mobile. 
The user may happen to be mobile, however applications do not adapt to different environments. 
This project addresses the issues faced in creating applications which can change to suit different environments. 
I show how relevant data sources in an environment can be found for applications, and how flexibility in the data they use can be achieved. 

\section{Problem}
% what's the problem

% describe current approach
Current applications tend to be inflexible in data sources they use, often selecting from a list of possibilities, regardless of the environment. 
While some localisation might be achieved by including parameters during connection, the possible parameters which will be accepted have already been fixed, restricting how well applications can adapt to their environment. 
The data formats that applications and data sources use have also been fixed, restricting applications even further.
By connecting to local data sources, applications gain greater flexibility due to the fact that the data sources reside within the same environment.
Given an application which requires the current temperature, a global server may use current GPS co-ordinates to determine the nearest weather station. 
Yet if the application were being used indoors, a value from a local temperature sensor might not only suffice, but be more appropriate. 
Perhaps this could be achieved otherwise, if the server had known about the temperature sensor, however why should the application need to connect to a global server in order to use a local connection? Perhaps there isn't even an Internet connection available. 
Furthermore, given that the user is mobile, the server would need to know about {\sl every} temperature sensor. 
Local data sources allow applications to use a dynamic set of data sources, more related to their environment. 

% context
Context refers to any event which the system or the user feels that it is reasonable to respond to, where any happening of interest that can be observed from within a computer is considered an event \cite[page 11]{muhl2006distributed}. 
Mobile devices constantly operate in different contexts, which dictate how devices can interact with the environment. 
Upon a change in context an application may no longer be able to communicate with a given data source, or the data it is providing may no longer be useful. 
In this situation, an alternative data source must be found.

Once this alternate data source has been found, the application must still determine whether it provides useful data. 
Some data may be fundamental to the operation of the application, while other parts may be desired, but not crucial.  
Even once a data source is deemed useful, the application may still face the difficulty of the data being presented in an alternate format to the expected format. 
Fields may be missing, there may be additional fields, and fields may have different names. 
The application may also wish to specify some subscription filter about the messages it should receive, yet without knowledge of the data format, it cannot specify filters on different fields.

% example
For example, a transport application may face differences in data available for coaches (Figure \ref{fig:coach-schema}) and for trains (Figure \ref{fig:train-schema}). 
While both offer similar data to a large extent, fields are named differently, and the train schema additionally offers a menu for an on-board shop.
Alternatively, the application might be used abroad, for example in a French coach station. The data will still be very similar, but fields names may be in French (Figure \ref{fig:french-coach-schema}).

While these differences may be important when the user is idly waiting in a station, they become less important when the user is running late and simply requires the departure time and location.
Given the amount of uncertainty about what data will be available, a developer creating this application cannot hope to account for all possibilities. 
However, the developer can specify how the application should behave in different contexts.

\section{Project}
% what I've done

Schilit et al \cite{schilit1994context}  define a context-aware system as one which can examine the computing environment and react to changes in the environment. 
This project creates such a system, which performs automatic contextual reconfiguration for applications whenever there is a change in the environment. 
Pascoe \cite{pascoe1998adding} lists four context-aware capabilites, two of which occur in this reconfiguration. 
Contextual resource discovery is used to discover data sources available within the context, and contextual adaptation allows applications to adapt to different data schemas in order to use the sources. 

% describe context, say only focusing on mobility (Wi-Fi) for now.
M\"{u}hl defines three kinds of events which can be used to detect a change in context: physical events, timer events, and a state change in the system \cite[page 11]{muhl2006distributed}, all of which may warrant some kind of reconfiguration. 
In a healthcare system, a rapid accelerometer change followed by no movement may represent a physical event (namely a fall), in which case the application may need to send data to an emergency response team.
A timer event indicates the progression of real time, which advertisers could use to connect to advertisements for nearby restaurants at lunch time. 
Finally, there are state changes in the system, such as a change in network connection or location. 
This project focuses on these state changes, particularly using a change in network connection to indicate a change in context. 

% policy engine
Applications control how their connections should be reconfigured through policies. 
The ``policy engine'' monitors the environment and upon detecting a change in context applies these policies, reconfiguring applications' connections to connect them to different data sources, where appropriate.
These policies may specify the name of data sources, or be more complex rules regarding the structure of data sources' schemas. 
Alternatively, applications may opt to be notified of a relevant change, rather than have their connection reconfigured, allowing them to perform callback methods upon a change.

% repackaging
Depending on the policy, an application may be connected to a data source which does not offer the expected data schema. 
The system handles this by repackaging messages to match the application's schema. Any extraneous fields are removed, any absent fields are filled with ``empty'' values, and the policy is used to infer relationships between fields with different names. 
Once the system has repackaged the message, it passes it to the application, allowing the application to continue as if it had received a message conforming to its schema.

% subscription
The system allows an application to specify subscription filters in terms of its own schema. 
As part of the reconfiguration process the system converts this subscription to match the peer's schema, connecting the application with a working subscription in place.

% pervasive computing
The system supports many of the goals of the pervasive computing vision \cite{weiser1991computer}.
Use of local data sources allows the system to be scalable. 
Connections are created on an ad-hoc basis, based entirely upon what data sources are available within the environment. 
This allows for a dynamic set of sources which can be modified at will. 
Repackaging messages achieves some level of heterogeneity within the system. 
Different environments may represent data in different formats, though application policies allow the system to interpret this data in a meaningful way. 
The policy engine can perceive context, and use these perceptions in an intelligent way, namely by reconfiguring applications' connections according to their policies. 
While all of this is invisible to the user, applications can be configured by the user through the use of policies \cite{saha2003pervasive}.

% summarise
The system automatically reconfigures applications' connections and repackages messages to fit their schemas, granting the applications flexibility in the data sources they use.
Local data sources can be used to provide data relevant to the environment, and by repackaging these messages an application is no longer bound to an exact schema. 
Applications control how they interact with an environment through policies, while still seamlessly communicating within that environment.

\cleardoublepage

 
\chapter{Preparation}

This chapter first outlines the requirements of the system. 
It then summarises related work which the project will build upon, namely the SBUS middleware \cite{ingram2009reconfigurable}. 
Finally, it describes how the system will be implemented to meet these requirements.

%Why the recursive discovery through peer inspection hasn't been implemented, and how it could be (should be somewhere else?)

\section{Requirements Analysis}

% use cases
John lives in a retirement village. He has a heart condition and as such he regularly suffers from falls. He uses a heart monitor connected to his phone and upon a fall wishes for his heart monitor readings to be sent the retirement village nurse. The nurse can then determine if John is in any immediate danger, and take appropriate action.

The following use cases show John's requirements of the system.

\begin{itemize}

\item {\bf Detect and Act upon Change in Context}

\begin{enumerate}

\item John has an application on his phone which displays readings from his heart monitor.

\item John is in his house, and falls over.

\item The system detects that John has fallen over.

\item The system connects John's heart monitor readings to the nurse's office in the retirement village, over the local network.

\item The nurse can check John's heart monitor readings, and dispatch an ambulance if necessary.

\end{enumerate}

\item {\bf Allow Mobility}

\begin{enumerate}

\item John enjoys visiting the local library, however since it is so large and often empty, John is concerned that he may suffer a fall which will go unnoticed.

\item The system will allow for this mobility, alerting an appropriate person wherever John is.

\end{enumerate}

\item {\bf Find Relevant Components}

\begin{enumerate}

\item John arrives at the library and connects his phone to the library's Wi-Fi network.

\item John goes about his business until he falls over while reaching for a book.

\item The system will find search the Wi-Fi network for an application which accepts heart rate readings, and connect John's readings to the application.

\item The library staff can then see that some kind of accident has happened, and search for John or call an ambulance.

\end{enumerate}

\item {\bf Allow Communication Between Incompatible Schemas}

\begin{enumerate}

\item John uses HeartMonitor 3000 which not only monitors his heart rate, but also blood pressure.

\item While the retirement village supports this system so can use John's heart rate and blood pressure, the library runs an outdated system which only supports heart rate.

\item The system will convert John's sensor readings to match the library's system, making the two systems compatible.

\end{enumerate}

\end{itemize}

\section{SBUS}

SBUS \cite{ingram2009reconfigurable} is a messaging middleware which can be used for stream based communication. 
The basic entity in SBUS is a {\sl component}. 
Each component consists of one or more {\sl endpoints} which can be connected, or {\sl mapped} together in order to communicate directly, rather than through some central server. 
Every endpoint has an associated message type, and in order for two endpoints to communicate their type must match. 
An endpoint may specify a subscription filter on events it wishes to receive. Any connected peer endpoints will only publish events to this endpoint if the event matches the subscription.

These connections and subscriptions are dynamically reconfigurable and may be modified by any other component, subject to security policies. 
This allows third party remapping to take place. A component may issue a message to some other component, instructing it to remap to another component's endpoints, or update its subscription filters.

The only central point of the system is a resource discovery component (RDC). 
The RDC itself is a component, and acts as a name service. 
Components may query the RDC for other components within the system, using parameters including component name, connected peers, or public key. 
The RDC will return IP addresses of matching components, allowing a direct connection to be established.

\section{System Design}

The system will be based upon the SBUS middleware, using and extending it to meet the requirements. 

% Android NDK
The system will be required to work on Android devices to allow for mobility. 
SBUS is written in C++ and will be ported to Android, rather than being completely rewritten. 
The Android Native Development Kit\footnote{http://developer.android.com/tools/sdk/ndk/index.html} (NDK) will be used to compile SBUS for Android, and the Java Native Interface (JNI) framework will be used to allow applications to use this library. 
Applications will then use SBUS for communication, accessing the library via the JNI methods.
Due to the fact that the NDK presents the largest unknown factor in the system, this work will be carried out first, allowing for modification to the project should it take more or less time than expected.

% How applications will find data sources relevant to them (constraints in terms of schema)
When components query the RDC they generally know something about the metadata of the component they want, such as its name, or connected peers. 
In a mobile system this is unlikely to be the case simply because of the scale of the system. 
Generally, there are too many possible environments for a component to know this information in every case. 
The system will be extended to allow components to search by the data they require. 
A component will then be able to search for a relevant component in any environment, without prior knowledge of components that exist within it.

% How applications will cope with unexpected data format - must be done at system level
SBUS endpoints can only communicate when they share a common message type. 
This ensures that endpoints only ever receive messages matching that type, so can values can be extracted from the message without problem. 
In a mobile system, applications cannot assume that data they require will always match the format which they expect. 
This means that applications may not know where a particular value is located within a message, so have to perform some complex parsing to find the value. 
To avoid each application having to parse every message, the system will handle messages which do not match the expected type. 
The system will reformat any incoming message before it reaches the endpoint, so that the endpoint only ever receives messages matching its type.

% How change in context will be detected
A typical smartphone offers many sensors which can be used to determine a context change. 
Android allows applications to register to receive intents\footnote{http://developer.android.com/reference/android/content/Intent.html} which indicate some event such as a network change, or an incoming phone call. 
Furthermore, the AIRS application\footnote{https://play.google.com/store/apps/details?id=com.airs} can be used to obtain sensor readings, which can be sent to a remote server. 
The system can use these intents and sensor readings to monitor the environment, and determine context changes. 
Upon detecting a context change, it can then remap other applications on the phone connecting them to peers suited to the environmental context. 

% How applications' connections will be reconfigured (spoke map)
In order for the system to remap applications, it needs to first know about them. 
An RDC is well suited for this, because it maintains a list of registered components, which can then be searched when a component queries the RDC. 
This list can also serve as a list of components which the system can remap.

These two aspects can be combined into a Phone Manager (PM) application. The PM will act similarly to an RDC, allowing applications to register with it. It will also detect context changes, and issue messages to registered components to instruct them to remap to other components upon these context changes.

% How the Phone Manager knows what to reconfigure to (policies)
The PM can remap applications upon a change in context, but must remap them to appropriate places. 
The PM cannot decide what constitutes ``appropriate'' for any given application, as such, the application must decide for itself. 
An application may register a {\sl policy} with the PM which dictates how it should be remapped upon a context change. 
This policy might be an IP address to map to, or a query which can be performed against an RDC in the environment to return matching components. 
The PM simply remaps applications as specified by their policies.

\cleardoublepage


% ~ 4000 words
\chapter{Implementation}

This chapter consists of three main parts. 
The first shows how applications can find data sources which offer the data they require, and how they can use these sources despite differences in schemas. 
The second part explains how the SBUS library was ported to Android, and how it can be used by application developers. 
Finally, this is all brought together with the Phone Manager which is responsible for detecting changes in context and reconfiguring applications' connections upon a change.

\section{Flexible Schema Matching}

\begin{itemize}

\item Syntax: +H, +S, what they mean. Nested searches +S[+H]

\item How system handles these - hashes.

\item Constructing looking table from these.

\item Repacking messages from lookup table.

\item Updating subscription from lookup table.

\item How RDC searches for matching schemas. Alternative search methods, e.g. hash table of linked lists or search tree. What performance increases they may offer, and how the results would vary (i.e. a breadth first search would return the schema which matches the constraints at the highest level).

\item Optimisations - reordering constraints - also don't repeat constraints.

\end{itemize}

How accurate is the lookup table? 
Are any fields repackaged as ``empty'' when we could have filled them with something else? 
Fairly qualitative, perhaps a discussion about how the constraints are used to create this lookup table, and how multiple constraints may be fulfilled by a single field.

Should multiple constraints (e.g. must have two int fields) be allowed to match to the same field?

\section{Android Port}

\begin{itemize}

\item Android NDK (write how bad the documentation is)

\item Rewriting method to get IP address

\item Putting files (sbuswrapper) onto phone - issues using Android FS without rooting.

\item JNI

\end{itemize}

\section{Policy Engine/Phone Manager}

\begin{itemize}

\item Policy engine - mini-RDC for phone

\item AIRS-SBUS gateway - events as context change

\item Dynamically add/remove RDC (rdc\_update endpoint). Callback method for find out about RDC

\item Ideas for where to get this RDC from (currently set by user)

\item How applications set policies.

\item Applying policies.

\end{itemize}

\cleardoublepage


% ~ Eval + Conclusion ~ 2000 words
\chapter{Evaluation}

The project set out to create a system which would allow applications to automatically reconnect to different sources upon a change in context, where these sources may not necessarily present data in the format expected. 
The project has been successful in this respect. Sensor readings from AIRS and Android intents are used to detect a change in context. After detecting a change, applications will be connected to sources which satisfy any constraints they have specified and messages will automatically be converted to applications' expected format, allowing operation of the application to continue without interruption.

\section{System Overview}

% overview of system image
\begin{figure}[tbh]
%set the image x size to the width of the page
\epsfxsize=\hsize
\centerline{\epsfbox{figs/overview.eps}}
\caption[System Overview]{The light blue boxes represent components and the green boxes within them represent endpoints. The purple boxes are lists of components registered with the RDC and Phone Manager, and the orange box is a list of policies set on the Phone Manager}
\label{fig:system_overview}
\end{figure}

Figure \ref{fig:system_overview} shows the interactions that occur within the system, detailing how a transport application which uses the coach schema in Figure \ref{fig:coach-schema} might have its connection reconfigured upon a change in context.

\begin{enumerate}

\item After the transport application has registered with the Phone Manager, it can send policies to the Phone Manager which specify how its endpoints should be reconfigured upon a change in context. For instance, the application may wish to be connected to any components which offer a structure matching the type of {\tt coach}. In another case, it may simply give an IP address it should be connected to.

\item The AIRS-SBUS gateway acts as a server for sensor readings from AIRS, which then emits the readings as SBUS events, which are consumed by the Phone Manager. The Phone Manager also receives other intents from Android, signalling a change in Wi-Fi network.

\item The Phone Manager processes these events to determine whether a change in context has occurred. Once a change happens, the Phone Manager will inform the transport application about the change by sending it details of whether an RDC should be added or removed. 

\item The transport application receives this message about the RDC change and will automatically accept this RDC change, registering or deregistering with the RDC, or perform some callback method, perhaps prompting the user to make a decision. The transport application may have chosen to automatically accept the change, but display a message to the user to indicate that the context has changed.

\item The Phone Manager applies all of the policies within its policy table, sending messages to application endpoints, instructing them to connect to different components. The transport application will be sent whatever it has set in its policy.

\item If the transport application has specified an IP address in its policy, the endpoint will receive this IP address and can connect directly to it to start receiving messages. However, if the policy specified that a component must have a structure matching the type of {\tt coach}, the endpoint will query the RDC with this constraint to find matching components.

\item The RDC searches components registered with it for those matching the constraints. In this case, it might find only a component sending coach data, while in other cases it may find components offering train data. In both cases, these components match the constraints, so the RDC returns the list of matching components to the application.

\item The application endpoint then connects to one of the matching component, allowing the user to continue receiving fresh travel data without any interaction needed.

\end{enumerate}

% table of example policies
\begin{table}[tbh]
\centering

\begin{tabular}{c c c c}
\hline\hline
Component & Endpoint & Remote Address & Remote Endpoint \\
\hline

Healthcare & HeartRate & 128.232.0.20:44444 & HeartRate \\
Transport & Departures & +NStagecoach & Coach \\
Transport & Departures & +Scoach & NULL \\

\hline
\end{tabular}

\caption{Phone Manager Example Policies}
\label{tab:example_policies}
\end{table}

% about example policies
Table \ref{tab:example_policies} shows example policies which components might set with the Phone Manager. 
Both the local component and local endpoint are implicitly set as whichever endpoint sent the policy. 
The remote address may be an IP address or a query to be resolved by an RDC. 
An IP address may be useful when the application should always be mapped to the same IP address. 
In the first example, a healthcare system has registered to have heart rate readings mapped directly to an endpoint at a known IP address, perhaps a relative or emergency response team. 
However the real flexibility of the system lies in the queries. 
These will be resolved by some RDC, ensuring components are mapped only to other components satisfying their queries. 
In the second row, the transport application sets a policy for any component named ``Stagecoach'' which has an endpoint named ``Coach'', while in the third row it sets a policy for any endpoint which has a structure matching the type of {\tt coach}. 

% event-condition-action through specifying AIRS sensor + condition
The system could easily be extended to an event-condition-action model, allowing applications to specify AIRS sensors to use as events, and actions to be taken upon an event satisfying some condition.

% table of example policies with events and conditions
\begin{table}[tbh]
\centering

\begin{tabular}{c c c c}
\hline\hline
Event & Condition & Component & Remote Address \\
\hline

Accelerometer & \begin{math} val \ge50 \end{math} & Healthcare & 128.232.0.20:44444 \\
Time & \begin{math} 12 \le val.hour \le 14 \end{math} & Adverts & +IRestaurant \\
Wi-Fi & \begin{math} val = true \end{math} & Transport & +NStagecoach \\
GPS & \begin{math} location(val) = France \end{math} & Transport & +Scoach \\

\hline
\end{tabular}

\caption{Phone Manager Example Policies using Event-Condition-Action Model}
\label{tab:event_condition_action}
\end{table}

% about examples
As shown in Table \ref{tab:event_condition_action}, applications would not only specify the action they wish to take through their map constraints, but also the events and conditions in which they wish to take that action.
The healthcare system could specify that it only wishes for heart rate data to be connected to the IP address if a high accelerometer value was measured, because the reading may indicate that a fall has occurred. 
The transport application can set different policies for different events. If a Wi-Fi connection is established, the application wants to connect specifically to Stagecoach components, however if a GPS event indicates that the user were in France, the application is more lenient and willing to accept any component offering a structure matching the type of {\tt coach}. 
The application may also display adverts, where policies could be used to determine the source of the adverts, perhaps from nearby restaurants around lunchtime. 

% user policies
This could further be used to allow the user to set their own policies for components. 
The application developer cannot possibly account for every scenario, however by allowing the user to set their own policies, through which they are specifying context changes they are interested in, the system becomes fully customisable and personal. 
The user of the transport application might not want to wait for a bus when it is raining. 
Therefore, they could create a policy using a weather event from AIRS, with the condition ``rain''. 
The action might be to connect the application to the IP address of a local taxi company, which provides information about when the next taxi will be available using the schema in Figure \ref{fig:taxi-schema}.

%UI for user to set policy (system can also set policy).


%TODO:

%Screenshots of original message + repackaged?

%How long to go through policy list (all the if statements)

%How long to tell a component about context change - long list, might take a while for last one - prioritise?

\section{System Performance}

% rdc search optimisation
\begin{figure}[tbh]
\epsfxsize=\hsize
\centerline{\epsfbox{figs/rdc_search_optimisations.eps}}
\caption[RDC Search Optimisations]{As seen from the graph, time taken to search for a schema increases linearly with the number of components registered. All optimisations perform more efficiently than searching without optimisation}
\label{fig:rdc_search_optimisations}
\end{figure}

Figure \ref{fig:rdc_search_optimisations} shows the time taken for a the RDC to search through all registered components to match schema constraints. 
As expected, the time taken to search increases linearly with the number of components registered. 
The structures first optimisation narrowly beats the exact first, and exact structures optimisations, all of which beat no optimisation. 
Even in the worst case, the RDC can perform the search with 100 other components registered in just over 40 milliseconds. 
This demonstrates that a schema search is not {\sl too} expensive, and will not impact performance on other components to a high extent. 

% construct lookup
\begin{figure}[tbh]
\epsfxsize=\hsize
\centerline{\epsfbox{figs/construct_lookup.eps}}
\caption[Construct Lookup Times]{Time taken to construct a lookup table between schemas of different sized producers and schemas of different sized consumers}
\label{fig:construct_lookup}
\end{figure}

Figures \ref{fig:construct_lookup} and \ref{fig:repack_message} both use a schema constraint which matches the type of the smallest schema.

Figure \ref{fig:construct_lookup} shows the time taken to construct a lookup table between schemas of different sized producers and schemas of different sized consumers. 
The general increase in time from left to right shows that more time is taken to construct a lookup table as the size of the producer schema increases, as expected, since there are more fields. 
The greater values in the upper right half of the graph show a disparity with the smaller values in the lower left half of the graph. 
This shows that the time taken to construct a lookup table is greater when the producer's schema is larger than the consumer's schema. 
This corresponds to searching in the larger producer schema for the smaller consumer schema to be matched, as opposed to simply finding the missing structures if the consumer schema were larger.
In either case, the lookup table is constructed once per connection, and takes microseconds.

% repack message
\begin{figure}[tbh]
\epsfxsize=\hsize
\centerline{\epsfbox{figs/repack_message.eps}}
\caption[Repackage Message]{Time taken to repackage a message between schemas of different sized producers and schemas of different sized consumers}
\label{fig:repack_message}
\end{figure}

Figure \ref{fig:repack_message} shows the time taken to repackage a message between schemas of different sized producers and schemas of different sized consumers. 
The general increase in time from top to bottom shows that more time is taken when the consumer schema is larger, as expected, because more fields are been repackaged. 
As with constructing the lookup table, messages are repackaged within microseconds.

\section{Android Port}
% TODO:
How long to map compared to on laptop?

How long to recieve messages compared to on laptop?

Android might have slower sockets - not my fault, but show where the bottlenecks are if in networking.

Stress test? How many components on Android can communicate?

Example code for Android SBUS component?

Screenshots?

\cleardoublepage

\chapter{Conclusion}

% summarise
The project has created a context-aware system which enables developers to write applications without prior knowledge of the location of data sources or the format of their data, decoupling applications from their data sources. 
The system supports the goals of pervasive computing by allowing scalability in the data sources used, heterogeneity in the data applications use, all while being invisible to the user.

The ``policy engine'' monitors the environment for events which the system or user believe to represent a change in context.
Upon detection of an event, the policy engine applies applications' policies, reconfiguring their connections as appropriate. 
Through these policies, applications may control which data sources they should be connected to, without requiring applications to find data sources themselves.
Policies may be simple, such as the name of a data source, or more complex, specifying how fields in a data source's schema must match their own. 

The system repackages messages so that applications will only ever be presented with data conforming to their own schema, removing uncertainty about the format of the data.
Furthermore, applications may specify subscription filters in terms of their own schemas, placing restrictions on which messages they will be sent, without requiring knowledge of peers' schemas.
When reconfiguring a connection, the system translates these filters to match the peer's schema and applies them to the peer, filtering messages as dictated by the application.

% example
Referring back to the transport example from the Introduction, there may be a transport application based on the coach schema (Figure \ref{fig:coach-schema}) which requires data sources to offer a structure matching the type of the {\tt coach} structure. 
At a coach station, all data sources match this schema exactly, so the application can connect to any one of them. 
The user may then travel to a larger station, offering train and coach services. 
Although train data sources use a different schema (Figure \ref{fig:train-schema}) to the application, their schema contains a structure matching the required {\tt coach} structure.
Upon arrival at the station, the user connects to the Wi-Fi network. The policy engine detects this change in context and connects the application to a train data source. 
Messages will be repackaged to match the application schema, meaning that the same code handles messages for coaches or trains.
The user might have subscribed to only receive data for which the departure time is after midday. 
Since this subscription is specified in terms of the coach schema, it will not function correctly if applied directly to the train schema. 
In this case, the system reformats the subscription to match the train schema and applies it when connecting the application to the data source, ensuring the user's subscription filter is met.

The application might equally have used the train schema, yet only required the {\tt info} structure, allowing it to use coach data sources.

\section{Issues}
% remaining problems
The system currently faces issues when context is rapidly changing, for example, moving in and out of range of a Wi-Fi network. 
The network connection drops causing the system to reconfigure connections, which may disconnect applications from their peers.
However, the network connection is almost immediately re-established causing the system to reconfigure connections again, possibly connecting applications to these same peers. 
If this reconnection occurs before disconnection has completed, the application believes itself to still be connected to the peer, thus will not create a new connection.

A solution to this problem might be to implement constraints which must be satisfied before reconfiguration occurs. 
In a Wi-Fi network, there may be a constraint that the network signal must be greater than a given threshold, meaning no reconfiguration would occur until the user moves firmly into the network. 
Alternatively, conditions on multiple context changes might be required before performing reconfiguration.  
For an accelerometer context change, a high accelerometer message followed by a message indicating little movement might be used to detect a fall.

\section{Changes}
% what I'd have done differently
{\sl I think this section might be more obvious after writing in the Preparation chapter about how the project was planned. }


\section{Future Work}
% other stuff that could be done

% alternate events for change in context - AIRS
Applications cannot currently specify changes in context which they are interested in. 
The policy engine will trigger all policies upon detecting a change.
Applications could specify the type of context change within their policy, with the ability to specify different policies for different context changes. 
This moves the system to an event driven architecture, where context changes are represented as events. 
Upon receiving an event, the policy engine would check whether the event satisfies the conditions of a policy, only applying the policy when does. 
This allows applications to specify policies for simple events, such as a Wi-Fi change event, to more complex events, such as a high accelerometer reading followed by no movement to represent a fall. 

As well as applications specifying policies, users could also specify policies for different applications. 
This moves the system further towards the pervasive vision. 
Applications would take sensible actions for different changes in context, however the user could refine how applications should react to changes in context, causing them to behave in a way more suited to the user's needs.

The user may have the ability to specify which types of events can be used. 
This offers some privacy to the user by allowing them to block applications from knowing if some part of their context has changed.

% qualify names if multiple fields in sensor have same name
The constraints applications specify about the schema of data sources they may be connected to are currently specified using the field names of their own schema.
While this works provided there are no repeated fields names within the schema, it would fail on a schema such as Figure \ref{fig:repeatednameschema}. 
A solution to this would be to qualify all names specified in the constraints in a similar way to subscriptions. 
We could specify a constraint for {\tt sensor}, meaning the entire structure, or {\tt sensor/sensor}, meaning the text field.

\begin{figure}[tbh]
\begin{lstlisting}
@sensor
{
	txt sensor
	int value
}
\end{lstlisting}
\caption[Schema with repeated name]{A schema with a structure named {\tt sensor} and a text field also named {\tt sensor}. A constraint specified on {\tt sensor} would be ambiguous without fully qualified names}
\label{fig:repeatednameschema}
\end{figure}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the bibliography

\addcontentsline{toc}{chapter}{Bibliography}
% nocite means add all references even if not cited - TODO: remove in final version
\nocite{*}
\bibliography{refs}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\begin{appendix}

\chapter{Possible Titles}

\begin{itemize}
\item Automatic Communication Configuration in Mobile Environments
\item Data Stream Connection and Message Negotiation
\item Flexibile Data Streams in Mobile Environments
\item Automatic Data Stream Configuration in Mobile Environments
\end{itemize}

\cleardoublepage

\chapter{Example Schemas}

\input{schemas}

\cleardoublepage

% should this be an appendix?
\chapter{Project Proposal}

\input{propbody}

\end{appendix}

\end{document}
