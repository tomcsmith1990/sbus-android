\documentclass[12pt,twoside,notitlepage]{report}

\usepackage{a4}
\usepackage{verbatim}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}

% set tab size for lstlisting
\lstset{tabsize=4}

\input{epsf}                            % to allow postscript inclusions
% On thor and CUS read top of file:
%     /opt/TeX/lib/texmf/tex/dvips/epsf.sty
% On CL machines read:
%     /usr/lib/tex/macros/dvips/epsf.tex



\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{6mm}       % adjust margins
\addtolength{\evensidemargin}{-8mm}

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\hfill{\LARGE \bf Thomas Smith}

\vspace*{60mm}
\begin{center}
\Huge
{\bf Automatic Configuration in Mobile Environments} \\
\vspace*{5mm}
Computer Science Tripos Part II \\
\vspace*{5mm}
Sidney Sussex College \\
\vspace*{5mm}
\today  % today's date
\end{center}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
Name:               & \bf Thomas Smith	\\
College:            & \bf Sidney Sussex College	\\
Project Title:      & \bf Automatic Configuration \\ &\bf in Mobile Environments	\\
Examination:        & \bf Computer Science Tripos Part II, 2013 	\\
Word Count:         & \bf 4352\footnotemark[1] \\
Project Originator: & Dr Jatinder Singh		\\
Supervisor:         & Dr Jatinder Singh		\\ 
\end{tabular}
}

\footnotetext[1]{This word count was computed by {\tt detex -e `appendix,figure' diss.tex | tr -cd `0-9A-Za-z $\tt\backslash$n' | wc -w}}
\stepcounter{footnote}


\section*{Original Aims of the Project}

The original aim of the project was to create a system which could adapt to the changes in context which come with mobility, such as location or networks. 
This required the ability to detect these changes, in order to find and connect to new data sources. 
As a new data source may have different data schema to the expected schema, the system must offer a way to make meaningful use of this data in relation to the expected schema.

\section*{Work Completed}

A messaging middleware was modified to allow users to search for data sources by aspects of their schema. Users can search for exact matches on some part of a schema, or a looser matches, considering field types only, not names.
Once this middleware was ported for use on Android, an application was created to monitor changes in context, particularly those that arise as a result of mobility. Upon detection of a change in context, the application informs other applications of the change, or automatically reconfigures their connections to connect them to a new data source, based on their policies.

\section*{Special Difficulties}

The main difficulty in the project came from porting the messaging middleware to Android. The Android NDK\footnote{http://developer.android.com/tools/sdk/ndk/index.html} toolkit was used in order to compile C++ for use on Android, however missing libraries and poor documentation made this task more difficult than expected.
 
\newpage
\section*{Declaration}

I Thomas Smith of Sidney Sussex College, being a candidate for Part II of the Computer
Science Tripos, hereby declare that this dissertation and the work described in it are my own work,
unaided except as may be specified below, and that the dissertation
does not contain material that has already been used to any substantial
extent for a comparable purpose.

\bigskip
\bigskip
\leftline{Signed: }

\bigskip
\bigskip
\leftline{Date: }

\cleardoublepage

\tableofcontents

\listoffigures

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\cleardoublepage        % just to make sure before the page numbering is changed

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

% Intro + Preparation ~ 1400 words
\chapter{Introduction}

% summarise
While many applications now exist for mobile devices, few applications themselves are truly mobile. 
The user may happen to be mobile, however applications do not adapt to different environments. 
This project addresses the issues faced in creating applications which can change to suit different environments. 
I show how relevant data sources in an environment can be found for applications, and how flexibility in the data they use can be achieved. 

\section{Problem}
% what's the problem

% describe current approach
Current applications tend to be inflexible in data sources they use, often selecting from a list of possibilities, regardless of the environment. 
While some localisation might be achieved by including parameters during connection, the possible parameters which will be accepted have already been fixed, restricting how well applications can adapt to their environment. 
The data formats that applications and data sources use have also been fixed, restricting applications even further.
By connecting to local data sources, applications gain greater flexibility due to the fact that the data sources reside within the same environment.
Given an application which requires the current temperature, a global server may use current GPS co-ordinates to determine the nearest weather station. 
Yet if the application were being used indoors, a value from a local temperature sensor might not only suffice, but be more appropriate. 
Perhaps this could be achieved otherwise, if the server had known about the temperature sensor, however why should the application need to connect to a global server in order to use a local connection? Perhaps there isn't even an Internet connection available. 
Furthermore, given that the user is mobile, the server would need to know about {\sl every} temperature sensor. 
Local data sources allow applications to use a dynamic set of data sources, more related to their environment. 

% context
Context refers to any event which the system or the user feels that it is reasonable to respond to, where any happening of interest that can be observed from within a computer is considered an event \cite[page 11]{muhl2006distributed}. 
Mobile devices constantly operate in different contexts, which dictate how devices can interact with the environment. 
Upon a change in context an application may no longer be able to communicate with a given data source, or the data it is providing may no longer be useful. 
In this situation, an alternative data source must be found.

Once this alternate data source has been found, the application must still determine whether it provides useful data. 
Some data may be fundamental to the operation of the application, while other parts may be desired, but not crucial.  
Even once a data source is deemed useful, the application may still face the difficulty of the data being presented in an alternate format to the expected format. 
Fields may be missing, there may be additional fields, and fields may have different names. 
The application may also wish to specify some subscription filter about the messages it should receive, yet without knowledge of the data format, it cannot specify filters on different fields.

% example
For example, a transport application may face differences in data available for coaches (Figure \ref{fig:coach-schema}) and for trains (Figure \ref{fig:train-schema}). 
While both offer similar data to a large extent, fields are named differently, and the train schema additionally offers a menu for an on-board shop.
Alternatively, the application might be used abroad, for example in a French coach station. The data will still be very similar, but fields names may be in French (Figure \ref{fig:french-coach-schema}).

While these differences may be important when the user is idly waiting in a station, they become less important when the user is running late and simply requires the departure time and location.
Given the amount of uncertainty about what data will be available, a developer creating this application cannot hope to account for all possibilities. 
However, the developer can specify how the application should behave in different contexts.

\section{Project}
% what I've done

Schilit et al \cite{schilit1994context}  define a context-aware system as one which can examine the computing environment and react to changes in the environment. 
This project creates such a system, which performs automatic contextual reconfiguration for applications whenever there is a change in the environment. 
Pascoe \cite{pascoe1998adding} lists four context-aware capabilites, two of which occur in this reconfiguration. 
Contextual resource discovery is used to discover data sources available within the context, and contextual adaptation allows applications to adapt to different data schemas in order to use the sources. 

% describe context, say only focusing on mobility (Wi-Fi) for now.
M\"{u}hl defines three kinds of events which can be used to detect a change in context: physical events, timer events, and a state change in the system \cite[page 11]{muhl2006distributed}, all of which may warrant some kind of reconfiguration. 
In a healthcare system, a rapid accelerometer change followed by no movement may represent a physical event (namely a fall), in which case the application may need to send data to an emergency response team.
A timer event indicates the progression of real time, which advertisers could use to connect to advertisements for nearby restaurants at lunch time. 
Finally, there are state changes in the system, such as a change in network connection or location. 
This project focuses on these state changes, particularly using a change in network connection to indicate a change in context. 

% policy engine
Applications control how their connections should be reconfigured through policies. 
The ``policy engine'' monitors the environment and upon detecting a change in context applies these policies, reconfiguring applications' connections to connect them to different data sources, where appropriate.
These policies may specify the name of data sources, or be more complex rules regarding the structure of data sources' schemas. 
Alternatively, applications may opt to be notified of a relevant change, rather than have their connection reconfigured, allowing them to perform callback methods upon a change.

% repackaging
Depending on the policy, an application may be connected to a data source which does not offer the expected data schema. 
The system handles this by repackaging messages to match the application's schema. Any extraneous fields are removed, any absent fields are filled with ``empty'' values, and the policy is used to infer relationships between fields with different names. 
Once the system has repackaged the message, it passes it to the application, allowing the application to continue as if it had received a message conforming to its schema.

% subscription
The system allows an application to specify subscription filters in terms of its own schema. 
As part of the reconfiguration process the system converts this subscription to match the peer's schema, connecting the application with a working subscription in place.

% pervasive computing
The system supports many of the goals of the pervasive computing vision \cite{weiser1991computer}.
Use of local data sources allows the system to be scalable. 
Connections are created on an ad-hoc basis, based entirely upon what data sources are available within the environment. 
This allows for a dynamic set of sources which can be modified at will. 
Repackaging messages achieves some level of heterogeneity within the system. 
Different environments may represent data in different formats, though application policies allow the system to interpret this data in a meaningful way. 
The policy engine can perceive context, and use these perceptions in an intelligent way, namely by reconfiguring applications' connections according to their policies. 
While all of this is invisible to the user, applications can be configured by the user through the use of policies \cite{saha2003pervasive}.

% summarise
The system automatically reconfigures applications' connections and repackages messages to fit their schemas, granting the applications flexibility in the data sources they use.
Local data sources can be used to provide data relevant to the environment, and by repackaging these messages an application is no longer bound to an exact schema. 
Applications control how they interact with an environment through policies, while still seamlessly communicating within that environment.

\cleardoublepage

 
\chapter{Preparation}

Why the recursive discovery through peer inspection hasn't been implemented, and how it could be (should be somewhere else?)

\cleardoublepage


% ~ 4000 words
\chapter{Implementation}

\section{Flexible Schema Matching}

Talk about the schema matching stuff - syntax, similar/exact, constructing lookup/repacking, subscriptions.

How accurate is the lookup table? 
Are any fields repackaged as ``empty'' when we could have filled them with something else? 
Fairly qualitative, perhaps a discussion about how the constraints are used to create this lookup table, and how multiple constraints may be fulfilled by a single field.

Should multiple constraints (e.g. must have two int fields) be allowed to match to the same field?

Alternative search algorithms for schema comparison in RDC. 
What performance increases they may offer, and how the results would vary (i.e. a breadth first search would return the schema which matches the constraints at the highest level).

\section{Android Port}

Talk about port - problems

\section{Policy Engine/Phone Manager}

Talk about policy engine - what it is, how it works, what it reacts to. AIRS SBUS gateway, how events from that signify context.

\cleardoublepage


% ~ Eval + Conclusion ~ 2000 words
\chapter{Evaluation}

The project set out to create a system which would allow applications to automatically reconnect to different sources upon a change in context, where these sources may not necessarily present data in the format expected. 
The project has been successful in this respect. Sensor readings from AIRS and Android intents are used to detect a change in context. After detecting a change, applications will be connected to sources which satisfy any constraints they have specified and messages will automatically be converted to applications' expected format, allowing operation of the application to continue without interruption.

\section{System Overview}

% overview of system image
\begin{figure}[tbh]
%set the image x size to the width of the page
\epsfxsize=\hsize
\centerline{\epsfbox{figs/overview.eps}}
\caption[System Overview]{The light blue boxes represent components and the green boxes within them represent endpoints. The purple boxes are lists of components registered with the RDC and Phone Manager, and the orange box is a list of policies set on the Phone Manager}
\label{fig:system_overview}
\end{figure}

Figure \ref{fig:system_overview} shows the interactions that occur within the system, detailing how a transport application which uses the coach schema in Figure \ref{fig:coach-schema} might have its connection reconfigured upon a change in context.

\begin{enumerate}

\item After the transport application has registered with the Phone Manager, it can send policies to the Phone Manager which specify how its endpoints should be reconfigured upon a change in context. For instance, the application may wish to be connected to any components which offer a structure matching the type of {\tt coach}. In another case, it may simply give an IP address it should be connected to.

\item The AIRS-SBUS gateway acts as a server for sensor readings from AIRS, which then emits the readings as SBUS events, which are consumed by the Phone Manager. The Phone Manager also receives other intents from Android, signalling a change in Wi-Fi network.

\item The Phone Manager processes these events to determine whether a change in context has occurred. Once a change happens, the Phone Manager will inform the transport application about the change by sending it details of whether an RDC should be added or removed. 

\item The transport application receives this message about the RDC change and will automatically accept this RDC change, registering or deregistering with the RDC, or perform some callback method, perhaps prompting the user to make a decision. The transport application may have chosen to automatically accept the change, but display a message to the user to indicate that the context has changed.

\item The Phone Manager applies all of the policies within its policy table, sending messages to application endpoints, instructing them to connect to different components. The transport application will be sent whatever it has set in its policy.

\item If the transport application has specified an IP address in its policy, the endpoint will receive this IP address and can connect directly to it to start receiving messages. However, if the policy specified that a component must have a structure matching the type of {\tt coach}, the endpoint will query the RDC with this constraint to find matching components.

\item The RDC searches components registered with it for those matching the constraints. In this case, it might find only a component sending coach data, while in other cases it may find components offering train data. In both cases, these components match the constraints, so the RDC returns the list of matching components to the application.

\item The application endpoint then connects to one of the matching component, allowing the user to continue receiving fresh travel data without any interaction needed.

\end{enumerate}

% table of example policies
\begin{table}[tbh]
\centering

\begin{tabular}{c c c c}
\hline\hline
Component & Endpoint & Remote Address & Remote Endpoint \\
\hline

Healthcare & HeartRate & 128.232.0.20:44444 & HeartRate \\
Transport & Departures & +NStagecoach & Coach \\
Transport & Departures & +Scoach & NULL \\

\hline
\end{tabular}

\caption{Phone Manager Example Policies}
\label{tab:example_policies}
\end{table}

% about example policies
Table \ref{tab:example_policies} shows example policies which components might set with the Phone Manager. 
Both the local component and local endpoint are implicitly set as whichever endpoint sent the policy. 
The remote address may be an IP address or a query to be resolved by an RDC. 
An IP address may be useful when the application should always be mapped to the same IP address. 
In the first example, a healthcare system has registered to have heart rate readings mapped directly to an endpoint at a known IP address, perhaps a relative or emergency response team. 
However the real flexibility of the system lies in the queries. 
These will be resolved by some RDC, ensuring components are mapped only to other components satisfying their queries. 
In the second row, the transport application sets a policy for any component named ``Stagecoach'' which has an endpoint named ``Coach'', while in the third row it sets a policy for any endpoint which has a structure matching the type of {\tt coach}. 

% event-condition-action through specifying AIRS sensor + condition
The system could easily be extended to an event-condition-action model, allowing applications to specify AIRS sensors to use as events, and actions to be taken upon an event satisfying some condition.

% table of example policies with events and conditions
\begin{table}[tbh]
\centering

\begin{tabular}{c c c c}
\hline\hline
Event & Condition & Component & Remote Address \\
\hline

Accelerometer & \begin{math} val \ge50 \end{math} & Healthcare & 128.232.0.20:44444 \\
Time & \begin{math} 12 \le val.hour \le 14 \end{math} & Adverts & +IRestaurant \\
Wi-Fi & \begin{math} val = true \end{math} & Transport & +NStagecoach \\
GPS & \begin{math} location(val) = France \end{math} & Transport & +Scoach \\

\hline
\end{tabular}

\caption{Phone Manager Example Policies using Event-Condition-Action Model}
\label{tab:event_condition_action}
\end{table}

% about examples
As shown in Table \ref{tab:event_condition_action}, applications would not only specify the action they wish to take through their map constraints, but also the events and conditions in which they wish to take that action.
The healthcare system could specify that it only wishes for heart rate data to be connected to the IP address if a high accelerometer value was measured, because the reading may indicate that a fall has occurred. 
The transport application can set different policies for different events. If a Wi-Fi connection is established, the application wants to connect specifically to Stagecoach components, however if a GPS event indicates that the user were in France, the application is more lenient and willing to accept any component offering a structure matching the type of {\tt coach}. 
The application may also display adverts, where policies could be used to determine the source of the adverts, perhaps from nearby restaurants around lunchtime. 

% user policies
This could further be used to allow the user to set their own policies for components. 
The application developer cannot possibly account for every scenario, however by allowing the user to set their own policies, through which they are specifying context changes they are interested in, the system becomes fully customisable and personal. 
The user of the transport application might not want to wait for a bus when it is raining. 
Therefore, they could create a policy using a weather event from AIRS, with the condition ``rain''. 
The action might be to connect the application to the IP address of a local taxi company, which provides information about when the next taxi will be available using the schema in Figure \ref{fig:taxi-schema}.

%UI for user to set policy (system can also set policy).


%TODO:

%Screenshots of original message + repackaged?

%How long to go through policy list (all the if statements)

%How long to tell a component about context change - long list, might take a while for last one - prioritise?

\section{System Performance}

% rdc search optimisation
\begin{figure}[tbh]
\epsfxsize=\hsize
\centerline{\epsfbox{figs/rdc_search_optimisations.eps}}
\caption[RDC Search Optimisations]{As seen from the graph, time taken to search for a schema increases linearly with the number of components registered. All optimisations perform more efficiently than searching without optimisation}
\label{fig:rdc_search_optimisations}
\end{figure}

Figure \ref{fig:rdc_search_optimisations} shows the time taken for a the RDC to search through all registered components to match schema constraints. 
As expected, the time taken to search increases linearly with the number of components registered. 
The structures first optimisation narrowly beats the exact first, and exact structures optimisations, all of which beat no optimisation. 
Even in the worst case, the RDC can perform the search with 100 other components registered in just over 40 milliseconds. 
This demonstrates that a schema search is not {\sl too} expensive, and will not impact performance on other components to a high extent. 

% construct lookup
\begin{figure}[tbh]
\epsfxsize=\hsize
\centerline{\epsfbox{figs/construct_lookup.eps}}
\caption[Construct Lookup Times]{Time taken to construct a lookup table between schemas of different sized producers and schemas of different sized consumers}
\label{fig:construct_lookup}
\end{figure}

Figures \ref{fig:construct_lookup} and \ref{fig:repack_message} both use a schema constraint which matches the type of the smallest schema.

Figure \ref{fig:construct_lookup} shows the time taken to construct a lookup table between schemas of different sized producers and schemas of different sized consumers. 
The general increase in time from left to right shows that more time is taken to construct a lookup table as the size of the producer schema increases, as expected, since there are more fields. 
The greater values in the upper right half of the graph show a disparity with the smaller values in the lower left half of the graph. 
This shows that the time taken to construct a lookup table is greater when the producer's schema is larger than the consumer's schema. 
This corresponds to searching in the larger producer schema for the smaller consumer schema to be matched, as opposed to simply finding the missing structures if the consumer schema were larger.
In either case, the lookup table is constructed once per connection, and takes microseconds.

% repack message
\begin{figure}[tbh]
\epsfxsize=\hsize
\centerline{\epsfbox{figs/repack_message.eps}}
\caption[Repackage Message]{Time taken to repackage a message between schemas of different sized producers and schemas of different sized consumers}
\label{fig:repack_message}
\end{figure}

Figure \ref{fig:repack_message} shows the time taken to repackage a message between schemas of different sized producers and schemas of different sized consumers. 
The general increase in time from top to bottom shows that more time is taken when the consumer schema is larger, as expected, because more fields are been repackaged. 
As with constructing the lookup table, messages are repackaged within microseconds.

\section{Android Port}
% TODO:
How long to map compared to on laptop?

How long to recieve messages compared to on laptop?

Android might have slower sockets - not my fault, but show where the bottlenecks are if in networking.

Stress test? How many components on Android can communicate?

Example code for Android SBUS component?

Screenshots?

\cleardoublepage

\chapter{Conclusion}

% summarise
The project has created a context-aware system which enables developers to write applications without prior knowledge of the location of data sources or the format of their data, decoupling applications from their data sources. 
The system supports the goals of pervasive computing by allowing scalability in the data sources used, heterogeneity in the data applications use, all while being invisible to the user.

The ``policy engine'' monitors the environment for events which the system or user believe to represent a change in context.
Upon detecting a change in context, the policy engine applies applications' policies, reconfiguring their connections as appropriate. 
Through these policies applications may control which data sources they should be connected to, without requiring applications to find data sources themselves.
Policies may be simple, such as the name of a data source, or more complex, specifying how fields in a data source's schema must match their own. 

The system repackages messages so that applications will only ever be presented with data conforming to their own schema, removing uncertainty about the format of the data.
Furthermore, applications may specify subscription filters in terms of their own schemas, placing restrictions on which messages they will be sent, without requiring knowledge of peers' schemas.
When reconfiguring a connection, the system translates these filters to match the peer's schema and applies them to the peer, filtering messages as dictated by the application.

% example
Referring back to the transport example from the Introduction, there may be a transport application based on the coach schema (Figure \ref{fig:coach-schema}) which requires data sources to offer a structure matching the type of the {\tt coach} structure. 
At a coach station, all data sources match this schema exactly, so the application can connect to any one of them. 
The user may then travel to a larger station, offering train and coach services. 
Although train data sources use a different schema (Figure \ref{fig:train-schema}) to the application, their schema contains a structure matching the required {\tt coach} structure.
Upon arrival at the station and connecting to a Wi-Fi network, the policy engine will detect a change in context and can connect the application to a train data source. 
Messages will be repackaged to match the application schema, meaning that the same code handles messages for coaches or trains.
The user might have subscribed to only receive data for which the departure time is after midday. 
Since this subscription is specified in terms of the coach schema, it will not function correctly if applied directly to the train schema. 
In this case, the system reformats the subscription to match the train schema and applies it when connecting the application to the data source, ensuring the user's subscription filter is met.

The application might equally have used the train schema, yet only required the {\tt info} structure, allowing it to use coach data sources.

\section{Issues}
% remaining problems
The system currently faces issues when context is rapidly changing, for example, moving in and out of range of a Wi-Fi network. 
The network connection drops causing the system to reconfigure connections, which may disconnect applications from their peers.
However, the network connection is almost immediately re-established causing the system to reconfigure connections again, possibly connecting applications to these same peers. 
If this reconnection occurs before disconnection has completed, the application believes itself to still be connected to the peer, thus will not create a new connection.

A solution to this problem might be to implement constraints which must be satisfied before reconfiguration occurs. 
In a Wi-Fi network, there may be a constraint that the network signal must be greater than a given threshold, meaning no reconfiguration would occur until the user moves firmly into the network. 
Alternatively, conditions on multiple context changes might be required before performing reconfiguration.  
For an accelerometer context change, a high accelerometer message followed by a message indicating little movement might be used to detect a fall.

\section{Changes}
% what I'd have done differently
{\sl I think this section might be more obvious after writing in the Preparation chapter about how the project was planned. }


\section{Future Work}
% other stuff that could be done

% alternate events for change in context - AIRS
Applications cannot currently specify changes in context which they are interested in. 
The policy engine will trigger all policies upon detecting a change.
Applications could specify the type of context change within their policy, with the ability to specify different policies for different context changes. 
This moves the system to an event driven architecture, where context changes are represented as events. 
Upon receiving an event, the policy engine would check whether the event satisfies the conditions of a policy, only applying the policy when does. 
This allows applications to specify policies for simple events, such as a Wi-Fi change event, to more complex events, such as a high accelerometer reading followed by no movement to represent a fall. 

As well as applications specifying policies, users could also specify policies for different applications. 
This moves the system further towards the pervasive vision. 
Applications would take sensible actions for different changes in context, however the user could refine how applications should react to changes in context, causing them to behave in a way more suited to the user's needs.

The user may have the ability to specify which types of events can be used. 
This offers some privacy to the user by allowing them to block applications from knowing if some part of their context has changed.

% qualify names if multiple fields in sensor have same name
The constraints applications specify about the schema of data sources they may be connected to are currently specified using the field names of their own schema.
While this works provided there are no repeated fields names within the schema, it would fail on a schema such as Figure \ref{fig:repeatednameschema}. 
A solution to this would be to qualify all names specified in the constraints in a similar way to subscriptions. 
We could specify a constraint for {\tt sensor}, meaning the entire structure, or {\tt sensor/sensor}, meaning the text field.

\begin{figure}[tbh]
\begin{lstlisting}
@sensor
{
	txt sensor
	int value
}
\end{lstlisting}
\caption[Schema with repeated name]{A schema with a structure named {\tt sensor} and a text field also named {\tt sensor}. A constraint specified on {\tt sensor} would be ambiguous without fully qualified names}
\label{fig:repeatednameschema}
\end{figure}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the bibliography

\addcontentsline{toc}{chapter}{Bibliography}
% nocite means add all references even if not cited - TODO: remove in final version
\nocite{*}
\bibliography{refs}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\begin{appendix}

\chapter{Possible Titles}

\begin{itemize}
\item Automatic Communication Configuration in Mobile Environments
\item Data Stream Connection and Message Negotiation
\item Flexibile Data Streams in Mobile Environments
\item Automatic Data Stream Configuration in Mobile Environments
\end{itemize}

\cleardoublepage

\chapter{Example Schemas}

\input{schemas}

\cleardoublepage

% should this be an appendix?
\chapter{Project Proposal}

\input{propbody}

\end{appendix}

\end{document}
